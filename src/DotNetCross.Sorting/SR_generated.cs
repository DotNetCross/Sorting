// Do not edit this file manually it is auto-generated during the build based on the .resx file for this project.
namespace System
{
    internal static partial class SR
    {
#pragma warning disable 0414
        private const string s_resourcesName = "FxResources.System.Memory.SR";
#pragma warning restore 0414

#if !DEBUGRESOURCES
        internal static string ArrayTypeMustBeExactMatch {
              get { return SR.GetResourceString("ArrayTypeMustBeExactMatch", null); }
        }
        internal static string CannotCallEqualsOnSpan {
              get { return SR.GetResourceString("CannotCallEqualsOnSpan", null); }
        }
        internal static string CannotCallGetHashCodeOnSpan {
              get { return SR.GetResourceString("CannotCallGetHashCodeOnSpan", null); }
        }
        internal static string Argument_InvalidTypeWithPointersNotSupported {
              get { return SR.GetResourceString("Argument_InvalidTypeWithPointersNotSupported", null); }
        }
        internal static string Argument_DestinationTooShort {
              get { return SR.GetResourceString("Argument_DestinationTooShort", null); }
        }
        internal static string MemoryDisposed {
              get { return SR.GetResourceString("MemoryDisposed", null); }
        }
        internal static string OutstandingReferences {
              get { return SR.GetResourceString("OutstandingReferences", null); }
        }
        internal static string Argument_BadFormatSpecifier {
              get { return SR.GetResourceString("Argument_BadFormatSpecifier", null); }
        }
        internal static string Argument_GWithPrecisionNotSupported {
              get { return SR.GetResourceString("Argument_GWithPrecisionNotSupported", null); }
        }
        internal static string Argument_CannotParsePrecision {
              get { return SR.GetResourceString("Argument_CannotParsePrecision", null); }
        }
        internal static string Argument_PrecisionTooLarge {
              get { return SR.GetResourceString("Argument_PrecisionTooLarge", null); }
        }
        internal static string Argument_OverlapAlignmentMismatch {
              get { return SR.GetResourceString("Argument_OverlapAlignmentMismatch", null); }
        }
#else
        internal static string ArrayTypeMustBeExactMatch {
              get { return SR.GetResourceString("ArrayTypeMustBeExactMatch", @"The array type must be exactly {0}."); }
        }
        internal static string CannotCallEqualsOnSpan {
              get { return SR.GetResourceString("CannotCallEqualsOnSpan", @"Equals() on Span and ReadOnlySpan is not supported. Use operator== instead."); }
        }
        internal static string CannotCallGetHashCodeOnSpan {
              get { return SR.GetResourceString("CannotCallGetHashCodeOnSpan", @"GetHashCode() on Span and ReadOnlySpan is not supported."); }
        }
        internal static string Argument_InvalidTypeWithPointersNotSupported {
              get { return SR.GetResourceString("Argument_InvalidTypeWithPointersNotSupported", @"Cannot use type '{0}'. Only value types without pointers or references are supported."); }
        }
        internal static string Argument_DestinationTooShort {
              get { return SR.GetResourceString("Argument_DestinationTooShort", @"Destination is too short."); }
        }
        internal static string MemoryDisposed {
              get { return SR.GetResourceString("MemoryDisposed", @"Memory<T> has been disposed."); }
        }
        internal static string OutstandingReferences {
              get { return SR.GetResourceString("OutstandingReferences", @"Release all references before disposing this instance."); }
        }
        internal static string Argument_BadFormatSpecifier {
              get { return SR.GetResourceString("Argument_BadFormatSpecifier", @"Format specifier was invalid."); }
        }
        internal static string Argument_GWithPrecisionNotSupported {
              get { return SR.GetResourceString("Argument_GWithPrecisionNotSupported", @"The 'G' format combined with a precision is not supported."); }
        }
        internal static string Argument_CannotParsePrecision {
              get { return SR.GetResourceString("Argument_CannotParsePrecision", @"Characters following the format symbol must be a number of {0} or less."); }
        }
        internal static string Argument_PrecisionTooLarge {
              get { return SR.GetResourceString("Argument_PrecisionTooLarge", @"Precision cannot be larger than {0}."); }
        }
        internal static string Argument_OverlapAlignmentMismatch {
              get { return SR.GetResourceString("Argument_OverlapAlignmentMismatch", @"Overlapping spans have mismatching alignment."); }
        }

#endif
        internal static Type ResourceType {
              get { return typeof(FxResources.System.Memory.SR); }
        }
    }
}
namespace FxResources.System.Memory
{
    // The type of this class is used to create the ResourceManager instance as the type name matches the name of the embedded resources file
    internal static class SR
    {
    }
}
